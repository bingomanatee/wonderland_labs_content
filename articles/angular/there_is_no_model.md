<svg width="768px" height="504px" viewBox="0 0 768 504" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
    <!-- Generator: Sketch 3.5.2 (25235) - http://www.bohemiancoding.com/sketch -->
    <title>plane</title>
    <desc>Created with Sketch.</desc>
    <defs>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="linearGradient-1">
            <stop stop-color="#FFFFFF" offset="0%"></stop>
            <stop stop-color="#C4C3C3" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">
        <path d="M749.914062,213.679687 C765.11558,200.530272 769.162929,180.46596 766.5,159.902344 C764.600847,145.23674 755.176609,116.600422 744.914062,108.125 C720.261719,87.7656249 732.054688,94.9999999 680.054688,94.9999999 C628.054688,94.9999999 509.734375,119.300781 450.359375,127.691406 C390.984375,136.082031 335.28938,154.473415 250.054687,179.515627 C195.277344,195.609377 143.195312,213.679689 98.765625,229.429681 C86.7773438,213.679689 66.0293625,172.601177 52.1523438,170.777345 C38.275325,168.953514 3.3203125,191.472658 3.3203125,191.472658 L39.0429688,276.527338 L18.0273438,374.679681 C18.0273438,374.679681 29.0039063,378.585931 50.4453125,378.585931 C71.8867188,378.585931 77.9570312,363.269525 82.0820312,352.585931 C86.2070312,341.902338 98.765625,309.59375 98.765625,309.59375 C98.765625,309.59375 113.09375,309.59375 183.332031,309.59375 C253.570312,309.59375 418.597656,299.357422 511.347656,276.527344 C604.097656,253.697266 723.871094,236.207031 749.914062,213.679687 Z" id="Path-4" fill="#D0011B" sketch:type="MSShapeGroup"></path>
        <path d="M586.652344,5.29854566 C570.816167,-3.04042587 536.13489,-0.366538116 485.106116,5.29854541 C434.077341,10.9636289 424.357341,20.25065 424.357341,20.25065 L246,503.272517 C246,503.272517 417.956005,504.000029 453.305931,504 C488.655858,503.999971 494.66387,500.138145 500.784963,478.205297 C506.906056,456.272449 586.652344,28.9881917 586.652344,5.29854566 Z" id="Path-5" fill="#D0011B" sketch:type="MSShapeGroup"></path>
        <g id="cockpit-framing" sketch:type="MSLayerGroup" transform="translate(214.000000, 107.000000)">
            <ellipse id="Oval-1" fill="#FFFFFF" sketch:type="MSShapeGroup" cx="193.5" cy="119.5" rx="193.5" ry="119.5"></ellipse>
            <ellipse id="Oval-1" fill="#7ED321" sketch:type="MSShapeGroup" cx="194" cy="119.5" rx="181" ry="112.5"></ellipse>
        </g>
        <path d="M491.499961,274.859776 L350.256145,271.079567 L355.701573,214.023041 L391.817027,196.947847 L473.889327,200.040016 L494.800951,215.032346 L494.592129,227.968585 L491.499961,274.859776 Z" id="cp-back" fill="#000000" sketch:type="MSShapeGroup"></path>
        <g id="control-panel" sketch:type="MSLayerGroup" transform="translate(320.000000, 162.000000)">
            <path d="M221.277344,35.109375 L159.082031,2.77734375 L52.265625,0 L0,20.359375 L34.640625,64.2070312 L72.0546875,44.109375 L148.363281,45.5 L174.667969,66.9023438 L221.277344,35.109375 Z" id="Path-1" fill="#8F8F8F" sketch:type="MSShapeGroup"></path>
            <ellipse id="Oval-2" fill="url(#linearGradient-1)" sketch:type="MSShapeGroup" cx="41" cy="28" rx="13" ry="11"></ellipse>
            <ellipse id="Oval-2-Copy" fill="url(#linearGradient-1)" sketch:type="MSShapeGroup" cx="182" cy="39" rx="13" ry="11"></ellipse>
            <ellipse id="Oval-2-Copy-2" fill="url(#linearGradient-1)" sketch:type="MSShapeGroup" cx="137.5" cy="14.5" rx="6.5" ry="5.5"></ellipse>
            <ellipse id="Oval-2-Copy-2" fill="url(#linearGradient-1)" sketch:type="MSShapeGroup" cx="117.5" cy="14.5" rx="6.5" ry="5.5"></ellipse>
            <ellipse id="Oval-2-Copy-2" fill="url(#linearGradient-1)" sketch:type="MSShapeGroup" cx="87.5" cy="14.5" rx="6.5" ry="5.5"></ellipse>
            <ellipse id="Oval-2-Copy-2" fill="url(#linearGradient-1)" sketch:type="MSShapeGroup" cx="67.5" cy="14.5" rx="6.5" ry="5.5"></ellipse>
        </g>
        <g id="stick" sketch:type="MSLayerGroup" transform="translate(408.000000, 179.000000)">
            <path d="M39.1386719,94.5670547 L42.2469146,38.669158 L16.9422271,3.37618929 C16.9422271,3.37618929 7.1766021,0.989470539 2.39925835,8.23947054 C-2.3780854,15.4894705 6.61019585,19.6965018 6.61019585,19.6965018 L27.9695709,42.5715018 L17.9851959,47.434783 L31.8328521,48.4738455 L29.2591152,94.5670547 L39.1386719,94.5670547 Z" id="Path-2" fill="#8B572A" sketch:type="MSShapeGroup"></path>
            <circle id="Oval-8" fill="#D0011B" sketch:type="MSShapeGroup" cx="9" cy="9" r="9"></circle>
        </g>
        <g id="model" sketch:type="MSLayerGroup" transform="translate(258.000000, 206.000000)">
            <g id="Group-Copy" sketch:type="MSShapeGroup">
                <rect id="Rectangle-1" fill="#787676" x="0" y="4.17857143" width="41" height="34.8214286"></rect>
                <ellipse id="Oval-9" fill="#D8D8D8" cx="20.5" cy="3.83035714" rx="20.5" ry="3.83035714"></ellipse>
            </g>
            <g id="Group" transform="translate(21.000000, 20.000000)" sketch:type="MSShapeGroup">
                <rect id="Rectangle-1" fill="#787676" x="0" y="4.17857143" width="41" height="34.8214286"></rect>
                <ellipse id="Oval-9" fill="#D8D8D8" cx="20.5" cy="3.83035714" rx="20.5" ry="3.83035714"></ellipse>
            </g>
        </g>
        <ellipse id="Oval-12" stroke="#979797" fill="#810111" sketch:type="MSShapeGroup" transform="translate(737.347656, 156.902344) rotate(-9.000000) translate(-737.347656, -156.902344) " cx="737.347656" cy="156.902344" rx="16" ry="40.5"></ellipse>
        <path d="M260,457.179688 L288.039062,455.097656 L320.207031,379 L282.746094,380.777344 L260,457.179688 Z" id="Path-6" stroke="#FFFFFF" stroke-width="2" sketch:type="MSShapeGroup"></path>
        <path d="M12.515625,362.941406 L44.640625,362.941406 L52.9726562,295.520999 L32.2453124,295.520999 L12.515625,362.941406 Z" id="Path-6-Copy-2" stroke="#FFFFFF" stroke-width="2" sketch:type="MSShapeGroup"></path>
        <path d="M2.0546875,254.641701 L17.8972165,260.761716 L45.0546875,204.921156 L17.8972165,193.761716 L2.0546875,254.641701 Z" id="Path-6-Copy-3" stroke="#FFFFFF" stroke-width="2" sketch:type="MSShapeGroup" transform="translate(23.554688, 227.261716) scale(1, -1) translate(-23.554688, -227.261716) "></path>
        <path d="M385.290601,88 L419.714278,86.4287499 L442.527345,30.3413111 L413.216078,30.3413111 L385.290601,88 Z" id="Path-6-Copy" stroke="#FFFFFF" stroke-width="2" sketch:type="MSShapeGroup"></path>
    </g>
</svg>

Angular does not have a builtin abstraction for [Domain Models](https://en.wikipedia.org/wiki/Domain_model). This is the biggest reason why tests in Angular (and React, and any JS/Frontend scenario) are a pain. 

Frontend apps tend to have a lot of responsibility sprawl. functionality goes in and out of many third party UI widgets and tests have to do a significant amount of folderol to mock/stub out these services. After a point your tests become self-referential, obtuse and difficult to maintain. 

The reason is my basic thesis that **Embedding state and values in a view system and mixing view logic and business logic creates very difficult to test scenarios.**

service/helper/domain components on the other hand are easy to test. They have properties, state and collections which can be designed for easy inspection. 

entire stages of business logic can be abstracted to object instances that have models, state(s) and change methods which can be triggered and tested to simulate whole systems, with mocks/stubs/models injected very easily. 

## A View to a Kill

View widgets often have hidden/difficult to access methods around updating and displaying values. A simple select widget can be nigh on impossible to test outside of full integration systems. But as a test writer you shouldn't have to be concerned with the flow of information into and out of the view layer, you should be focused on writing as many scenarios as you can around the model and business components. When those components are identical to the view layer this becomes difficult. 

And I maintain if the majority of your tests are running view code then your application is badly factored. You shouldn't have to run any third party or view logic to simulate activity on your app. 

Ideally the control and model of your app should be detached and testable without direct reference to your view and dom. If you code is properly factored it should run like a flight simulator: all the data and control services should be wired such that they can run in test mode without the presence of the rest of the airplane (i.e., the DOM/Selenium/Protractor). 

Angular doesn't mandate that the view and data be too tightly bound but it does in some ways encourage it. I'd recommend a more discrete architecture, with testable model/domain classes that bind into the controller layer only as much as is necessary to get the data and mutability working.

## Binding Models to Views

There are two basic models for view/model binding: 

1. bind your model to a single variable/property in the scope and bind the view widgets to model properties
2. create two way binding between model properties and view properties

The latter is in general easier to do if you have a migration scenario where you want to migrate an existing apps' business practices away from the view layer. The former (directly adding the model to the view/scope) is easier and has less binding code. 

But in any case if you are able to separate your view logic from your business logic, your tests and code become much more elegant. 

One thing to keep in mind: in angular it is often useful to be able to control the frequency of view updates and to debounce full refreshes in controlled bursts. If you bind your model directly and refer to its properties and (even worse) methods, then those properties have to be polled every time the view is redrawn, and any validation code etc. present in them is called every digest cycle. Whereas, if you transmit scalar data from the model to the $scope or controller (and back), you will probably see fewer digest cycles and more contained view updates. 

## A very abbreviated use case 

Say you want to make a shopping app. You design this around some basic domain models:

```

PayMethod: 
  name: String,
  charge(amount): Promise

User:
  identity: {name, email...},
  paymentMethods: [PayMethod],

Cart: 
  user: User,
  products: [Product],
  shipTo: Address,
  paymentMethod: PayMethod
  state: [empty, hasProducts, paying, paid, payFailure...]
  checkout() : Promise,
  cartValue() : Number
```

You can simulate the entire checkout process, checking 
* state
* cartValue()
* completeness of cart (has payementMethod, etc)
* what if the payment fails

etc., without worrying about the strength of the view layer. Only when your business scenarios are validated do you need to move to testing your view, at which point as long as you prove that when the business model changes, the view reflects it, you don't have to integration test every scenario; the scenarios can be unit tested which is in general faster and easier to write and maintain.

## The Flight Simulator 

As mentioned before, this approach can be compared to the flight simulator line of thought. A flight simulator doesn't require construction of the entire aircraft. At minimum it doesn't even require a fully constructed cockpit; it just requires two things: 

1. The pilot gets a realistic set of signals from the "window" and his dashboard
2. The pilot can use the equivalent "map" of all of the important controls in the simulator that he has in a real cockpit. 

I.e., it doesn't matter that the control for a particular aircraft to lower and raise the gear is a lever; if you press the button for lower/raise gear, you have "mapped" the ability of the pilot to operate the gear, and that's all that matters. Similarly, the pilot needs an indicator that tells him whether his gear is lowered or raised. (Assuming that in a real plane this information is available. 

Creating a Domain is like constructing a flight simulator. As long as you can send and receive all relevant signals for operating the system, you can reconstruct the experience that the Domain is intended to model. 

Domains can often extend through several controllers, components, and directives. This gives them cross-systems access to a range of inputs and outputs. For instance, one directive might be a modal that lists the cart's content. Another might be a text message that describes a summary of the cart ('empty', '3 items', etc.) A third might be a form to choose a payment method for the cart. 

You can accomplish this through scope injection or by a singleton service as appropriate. The latter greatly simplifies testing, as you don't have to reconstruct the scope; if the scope's methods access a singleton service, your end to end test can run an instruction of a directive (say, removing an item from a cart or changing an item's quantity) and the singleton can be inspected to ensure that the proper result occurs. 

Once all the directives' local methods have been tested, you have enough coverage to run scenarios purely around the Domain itself. I.e., you don't have to simulate the actual gear for every test -- you just have to simulate the gear indicator and raise/lower gear button.