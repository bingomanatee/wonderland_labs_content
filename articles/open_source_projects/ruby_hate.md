I have worked with Ruby on and off for years; I came to it from PHP (which let's face it, is glorified Perl) and while using it discovered Node. 

It is probably not a good thing; had I not, I'd bee one of the many well-compensated Ruby people for whom this industry has a seemingly unquenchable thirst. But I can't in good conscience advocate a language with such obvious built-in problems for any organization who believes that they want to be on the cutting edge, and will last more than a year or two. 

I especially can't advocate it for any organization that invests in JavaScript, because by definition, you are forced to hire two tiers of developers: frontend Javascript developers and backend Ruby devs. Each will prefer one style of development over another, to the detriment of the whole, as both backend and frontend development has its place. Javascript/frontend code, of course, knows its place and thoroughly owns it. Ruby on the other hand, does not and continually builds full-stack modules which means that the ownership and maintenance of frontend-related systems is given over to backend developers who aren't as well versed in the art as their frontend peers. 

You may say that cultural arguments are not relevant to the discussion of internet technologies. I'd argue that they are the *most important arguments* to make in the creation of a startup, as these cultural arguments will impact your scaling, staffing, and scale and speed of expansion. 

Node houses don't see this division; you won't have a site erected in node where the frontend developers are too gunshy to poke in and revise and maintain the backend code. They will, in fact, be literally speaking the same -- or mostly same -- language. And a Node developer won't be as motivated to creating tools that put the responsibility of view-related tasks in the backend because even those tasks they push to the frontend are within their wheelhouse. 

I could go on about how Ruby is over invested in the old school OOP pattern of development; about how they use patterns like symbols that jostle for plain strings in a way that will remain confusing or irritating for years; about how easy it is to overapply helper systems like state machines and validation that give you great first-run results, then remain a source of sluggishness as you attempt to force these general systems to solve specific tasks. 

I can even complain about how inherently slow Ruby is; and how it trades a customer facing virtue --speed -- for a developer-facing virtue, (supposed) speed of development -- a decision that only narcissistic millennials could find reasonable. Despite how absolutely cemented the concept of the relationship between speed of download and [good customer experience](http://stevesouders.com/) is in the collective wisdom of the web it is a lesson that younger programmers ignore, because it is inconvenient to them after they have swallowed the cool-aid of middle-management pleasing rapid development over the existential value of the resulting product. 

And in fact, its not Ruby that is often the culprit, but Rails itself. Rails is a fairly good use case in bundled, brain numbing framework. Where it "makes things easy" by pushing design decisions deep into a suite of custom code, it also canonizes things like active record that should really be adopted after a decision making process rooted in a deep understanding of the way a tasks' data needs to be handled. So much so that when systems like Redis and Mongo, whose strength is that they are faster and more straightforward in many cases than ActiveRecord and SQL, are forced to adapt to the ActiveRecord pattern (at the cost of their hard-fought gains in speed and adaptability) to appeal to Ruby devotees. 

So, if and when you feel obligated to push up a site fast and with little decisionmaking, or you don't feel courageous enough to go against the established wisdom that Ruby and Rails are the only good way to make a website, run with the herd. Only remember, when you run with the herd, you have admitted to yourself that you are not someone capable of making insightful independent decisions for the best long term growth of your company; and if you truly do not believe yourself capable of making decisions, you might for the benefit of those you work with, find other roles to fulfill where you are less likely to cause those around you to suffer.

## Isn't this true of all server side languages (that are not node?) 

In theory, perhaps; in practice, the Ruby community has been overenthusiastic about publishing generalized solutions to make everything "Easy". The end result is that any time you roll into a site you have to learn not only the client side system that has been encased in a ruby gem, but the gems quirks.

### You're not helping

What this means is that gems that inject the support systems for a widget (say, Angular, Bootstrap, etc.) will version freeze the dependencies the widget needs; this means if you use two independent backbone based widget, you might end up with two different versions of a client side library in your page, each derived from a different widget gem. 

In short the widgets that span the server/client level can exist in Rails because of how completely the templating system in Rails has been made uniform and conventional. As is often the case, the overenthuasiasm of the framework becomes a real chore; of course, you don't have to use these widgets, but often ruby projects get passed around like a drunk coed and these sort of decisions are not yours to make.

My previous experience in PHP, Struts, and Drupal (which shares this issue) drives me to believe that these languages(but Drupal), bereft of the gift of gems, lack this problem.