One of the areas I find most telling about frameworks in general and web frameworks in specific is the "WTF Index"; that is, how much of my time do I spend wondering why things I think should work aren't. And further, when I am boggled how much of the time do I spend not even knowing what component or line of code is causing the problem. 

Neither Angular nor React is innocent of causing WTF moments. With angular it is usually in the form of "The Digest Cycle is eating its own ass; sucks to be you" where in react its in the form of "The Dom has been molested! Heaven forfend, I do believe I may faint!" And its usually just that specific. "We don't like the DOM." Not a particular DOM node, no that is TMI. Just the DOM in general. 

Admittedly, given that both frameworks will leave you beached, it is worthwhile noting that in my experience React manufactures far more unhelpful errors than Angular. Given its youth this is to be expected. In fact I'd say that while Angular is pretty good at letting you know what part of the code is screwy it often does so in the form of links to its documentation that contain metadata about the error. This technical debt of depending on a remote site to be up and accessible for your debug messages to work is pretty unhealthy; what about us sewer programmers who may not have the most reliable access to net connectivity? 

## Testing my patience

Another beef I have with both frameworks is that getting testing to work properly is not a slam dunk in either framework. And worse yet they both pretty much bully you into a single framework (Jest for React, Karma for Angular) to get your tests running. I'm fairly used to, as a JS / Node developer, having no restrictions on testing frameworks; I can use TAP (node tap, thanks to Isaac S., the NPM maintainer) or Mocha or Jasmine or even DIY if I want to. Going outside the lines in either Angular or React is a very dark and mysterious journey. 

Further even if you try to toe the line both frameworks' unique architectures make testing fairly foreboding. There are terse examples of testing working with React and Jest, but I've yet to get anything to work well under Jest. One of the big problems is it auto-mocks nearly everything, and you have to actively whitelist code files to get them to load (instead of getting stubbed out); for deep dependencies this is a pain in the ass. 

Angular makes testing suck with a very particular injection model. 

My "A pox on both your houses" attitude is rooted in how easy node modules, by contrast, are to test. 
When you pull a node module into a test scenario, you basically auto-load all its dependencies and you generally have near perfect control over your test subjects' environment. It is true that mocking and stubbing related dependencies is basically a non-starter but if your own code uses injection you can usually make that happen in short order. 

So while neither frameworks are stellar from the testability POV, to date I find I am actually able, with hours of research, to get Angular to test, while I'm still hitting massive dead ends with Jest. I don't think its a coincidence that the starter repos for React don't feature much (or any) test coverage on their sample code. 

## Readability 

Another frequent WTF roadblock is inheriting code that someone else (or you) wrote a while ago and not being able to understand or follow it. This usually breaks down into one of three areas:

1. Mysterious resource referencing/linking
2. Strange template design
3. Difficult to follow dynamic coding

I have to say one of the things that makes React standout is that its tempting language is fundamentally solid. One reason is that its template language has zero logical constructs; its purely tag and one-way inserted values. If you do need template logic that logic is native JS, and is external to the templates themselves. it's very easy to inject larger structures from helper functions/methods.classes as in 

``` javascript

render() {
  var rand = Math.random();
  return (<div><div className="userPortrait">{ this.userPortrait() } {rand} </div>
<h2>{ this.state.username }</div> ); 
}
```

tracing the injected values, whether they are references to local variables, methods, properties, state or external helpers, is made very trackable because there is only one non-HTML style allowed in the template language: `{ native javascript }`. Angulars extra-functional tags and attributes often make for more difficult logic; and I say more difficult, not absolutely difficult, as its template language is for the most part well documented and easy to follow once you submerge yourself in its idiosyncrasies.